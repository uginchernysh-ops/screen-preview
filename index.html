<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Screen Preview с масштабированием</title>
  
  <!-- PWA мета-теги -->
  <meta name="theme-color" content="#3498db">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: url('images/Back.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #ecf0f1;
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
      position: relative;
      transition: background 0.3s ease;
    }
    body::before { 
      content: ''; 
      position: absolute; 
      inset: 0; 
      background: rgba(44,62,80,0.85); 
      z-index: -1; 
      transition: background 0.3s ease;
    }

    .logo-container { text-align: center; margin-bottom: 15px; }
    .logo { max-width: 200px; height: auto; margin-bottom: 10px; }

    .interface-container {
      max-width: 1800px;
      margin: 0 auto; 
      background: rgba(44,62,80,0.7);
      border-radius: 15px; 
      padding: 20px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      transition: max-width 0.3s ease;
    }

    header { text-align: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    h1 { font-size: 2.2rem; margin-bottom: 8px; color: #3498db; }
    .subtitle { font-size: 1.1rem; opacity: 0.8; }

    .main-content { 
      display: flex; 
      gap: 25px; 
      flex-wrap: wrap; 
    }

    .control-panel {
      flex: 0 0 300px; 
      background: rgba(52,73,94,0.8); 
      padding: 20px; 
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      transition: transform 0.3s ease, opacity 0.3s ease, background 0.3s ease;
    }
    .control-group { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .control-group:last-child { border-bottom: none; }
    h2 { font-size: 1.3rem; margin-bottom: 15px; color: #3498db; }
    label { display: block; margin-bottom: 8px; font-weight: 500; }

    select, input[type="file"], input[type="range"], input[type="color"] {
      width: 100%; padding: 10px; margin-bottom: 15px; border: none; border-radius: 5px;
      background: #2c3e50; color: #ecf0f1; font-size: 1rem;
      transition: background 0.3s ease, outline 0.2s ease;
    }
    input[type="range"] { padding: 0; height: 8px; -webkit-appearance: none; background: #34495e; border-radius: 4px; }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: #2980b9;
      transform: scale(1.1);
    }
    button {
      width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 5px;
      font-size: 1rem; cursor: pointer; transition: all 0.3s ease; margin-bottom: 10px;
    }
    button:hover { background: #2980b9; transform: translateY(-1px); }
    button:active { transform: translateY(0); }

    button:focus, select:focus, input:focus {
      outline: 2px solid #3498db;
      outline-offset: 2px;
    }

    .color-preview { width: 30px; height: 30px; border-radius: 5px; border: 2px solid #ecf0f1; margin-top: 5px; transition: background 0.3s ease; }

    .preview-section { 
      flex: 1; 
      min-width: 300px; 
    }
    .preview-container {
      position: relative; 
      width: 100%; 
      height: 70vh;
      min-height: 450px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px; 
      overflow: auto;
      display: flex; 
      justify-content: center; 
      align-items: center;
      margin-bottom: 15px; 
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .preview-container::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .preview-container::-webkit-scrollbar-thumb {
      background: rgba(52, 152, 219, 0.5);
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    .preview-container::-webkit-scrollbar-thumb:hover {
      background: rgba(52, 152, 219, 0.8);
    }

    #screenContainer {
      position: relative; 
      transform-origin: center center; 
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      max-width: 100%;
      max-height: 100%;
    }

    #maskImage, #fallbackCanvas { 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      z-index: 1; 
      pointer-events: none; 
      object-fit: contain;
    }
    #videoPlayer { 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      object-fit: contain; 
      z-index: 2; 
      transition: opacity 0.3s ease;
    }
    #previewCanvas { 
      position: absolute; 
      inset: 0; 
      width: 100%; 
      height: 100%; 
      z-index: 2; 
      transition: opacity 0.3s ease;
    }

    /* Сетка */
    .show-grid {
      background-image: 
        linear-gradient(rgba(52, 152, 219, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(52, 152, 219, 0.1) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .loading-indicator {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 15px 25px; 
      border-radius: 8px; 
      z-index: 5; 
      display: none;
    }
    
    .loading-indicator::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    /* Прелоадер для файлов */
    .file-loading {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(52, 152, 219, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 10;
      font-size: 0.9rem;
    }

    .preloader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }

    .spinner {
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 3px solid #3498db;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Скелетон-загрузка */
    .skeleton-loading {
      background: linear-gradient(90deg, #34495e 25%, #2c3e50 50%, #34495e 75%);
      background-size: 200% 100%;
      animation: loading 1.5s infinite;
      border-radius: 5px;
    }

    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .placeholder-message {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%,-50%);
      text-align: center; 
      color: rgba(255,255,255,0.6); 
      z-index: 0;
      transition: opacity 0.3s ease;
    }

    .screen-info {
      background: rgba(52,73,94,0.8); 
      padding: 15px; 
      border-radius: 10px; 
      box-shadow: 0 5px 15px rgba(0,0,0,0.2); 
      margin-bottom: 15px;
      transition: background 0.3s ease;
    }
    .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; }
    .info-item { background: rgba(44,62,80,0.5); padding: 10px; border-radius: 8px; transition: background 0.3s ease; }
    .info-label { font-size: 0.9rem; opacity: 0.7; margin-bottom: 5px; }
    .info-value { font-size: 1rem; font-weight: 500; }

    .error-message { color: #e74c3c; margin-top: 10px; display: none; }
    .success-message { color: #2ecc71; margin-top: 10px; display: none; }

    .control-panel-toggle { display: none; position: fixed; top: 15px; left: 15px; z-index: 1000; width: auto; padding: 10px 15px; background: #3498db; border-radius: 5px; }
    .fullscreen-btn-container { text-align: center; margin-top: 10px; }
    #fullscreenBtn { width: auto; padding: 8px 15px; font-size: 0.9rem; }

    .hotkeys-info {
      background: rgba(44,62,80,0.5);
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .hotkeys-info kbd {
      background: #2c3e50;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #34495e;
      font-family: monospace;
    }

    /* Новые кнопки инструментов */
    .tools-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 15px;
    }

    .tools-grid button {
      margin-bottom: 0;
      font-size: 0.9rem;
      padding: 8px;
    }

    .fps-counter {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #2ecc71;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10;
      display: none;
    }

    /* Фильтры изображений */
    .filters-panel {
      background: rgba(44,62,80,0.6);
      padding: 15px;
      border-radius: 8px;
      margin-top: 10px;
    }

    .filter-slider {
      margin-bottom: 10px;
    }

    .filter-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
    }

    @media (max-width: 1024px) {
      .interface-container {
        max-width: 95%;
      }
      .preview-container {
        height: 60vh;
      }
    }

    @media (max-width: 768px) {
      .main-content { flex-direction: column; }
      .control-panel { 
        position: fixed; 
        top: 0; 
        left: -100%; 
        width: 80%; 
        max-width: 300px; 
        height: 100vh; 
        z-index: 999; 
        overflow-y: auto; 
        transition: left 0.3s ease; 
      }
      .control-panel.active { left: 0; }
      .control-panel-toggle { display: block; }
      .preview-container { height: 50vh; }
      .logo { max-width: 150px; }
      .tools-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (min-width: 2000px) {
      .interface-container {
        max-width: 2200px;
      }
      
      .preview-container {
        height: 80vh;
      }
    }

    @media (prefers-color-scheme: dark) {
      body::before {
        background: rgba(20, 30, 40, 0.9);
      }
      
      .control-panel {
        background: rgba(30, 40, 50, 0.95);
      }
    }
  </style>
</head>
<body>
  <button class="control-panel-toggle" id="panelToggle">☰ Панель управления</button>

  <div class="interface-container">
    <div class="logo-container">
      <img src="images/connect_logo-1.jpg" alt="Connect Logo" class="logo"
           onerror="this.onerror=null;this.src='images/connect_logo-1.png'">
    </div>

    <header>
      <h1>Screen Preview с масштабированием</h1>
      <p class="subtitle">Просмотр контента на различных экранах с сохранением оригинальных пропорций</p>
    </header>

    <div class="main-content">
      <div class="control-panel" id="controlPanel">
        <div class="control-group">
          <h2>Экран</h2>
          <label for="screenSelect">Выберите экран:</label>
          <select id="screenSelect">
            <option value="Bolshoi">Большой экран (6528×1472)</option>
            <option value="Poloski">Экран полоски (640×1920)</option>
            <option value="Nav">Навигация (316×384)</option>
            <option value="Bar1">Бар 1 (384×64)</option>
            <option value="Bar2">Бар 2 (256×64)</option>
            <option value="Recepshen">Рецепшен (2176×1280)</option>
            <option value="TualetM">Туалет мужской (284×256)</option>
            <option value="TualetW">Туалет женский (284×256)</option>
            <option value="TualetPotolok">Туалет потолок (383×384)</option>
            <option value="Lestnitsa">Экран на лестнице (200×120)</option>
          </select>

          <label for="uploadInput">Загрузить контент:</label>
          <input type="file" id="uploadInput" accept="image/*,video/*">
          <div class="error-message" id="uploadError"></div>
          <div class="success-message" id="uploadSuccess"></div>
        </div>

        <div class="control-group">
          <h2>Масштаб</h2>
          <label for="scaleSlider">Масштаб: <span id="scaleValue">100%</span></label>
          <input type="range" id="scaleSlider" min="10" max="400" value="100">
          
          <div class="tools-grid">
            <button id="zoomInBtn">Увеличить (+)</button>
            <button id="zoomOutBtn">Уменьшить (-)</button>
            <button id="autoFitBtn">Автоподгон (Ctrl+0)</button>
            <button id="rotateBtn">Повернуть 90°</button>
          </div>
          
          <div class="hotkeys-info">
            <kbd>Ctrl</kbd> + <kbd>+</kbd>/<kbd>-</kbd> - масштаб | <kbd>Ctrl</kbd> + <kbd>F</kbd> - полный экран
          </div>
        </div>

        <div class="control-group">
          <h2>Режим отображения</h2>
          <label for="displayMode">Режим:</label>
          <select id="displayMode">
            <option value="contain">Вписать (contain)</option>
            <option value="cover">Заполнить (cover)</option>
            <option value="stretch">Растянуть</option>
            <option value="original">Оригинальный размер</option>
          </select>
          
          <label>
            <input type="checkbox" id="toggleGridBtn"> Показать сетку
          </label>
        </div>

        <div class="control-group">
          <h2>Фильтры изображений</h2>
          <div class="filters-panel">
            <div class="filter-slider">
              <div class="filter-label">
                <span>Яркость:</span>
                <span id="brightnessValue">100%</span>
              </div>
              <input type="range" id="brightnessSlider" min="0" max="200" value="100">
            </div>
            
            <div class="filter-slider">
              <div class="filter-label">
                <span>Контраст:</span>
                <span id="contrastValue">100%</span>
              </div>
              <input type="range" id="contrastSlider" min="0" max="200" value="100">
            </div>
            
            <div class="filter-slider">
              <div class="filter-label">
                <span>Насыщенность:</span>
                <span id="saturationValue">100%</span>
              </div>
              <input type="range" id="saturationSlider" min="0" max="200" value="100">
            </div>
            
            <button id="resetFiltersBtn">Сбросить фильтры</button>
          </div>
        </div>

        <div class="control-group">
          <h2>Внешний вид</h2>
          <label for="contentOpacity">Прозрачность контента: <span id="opacityValue">100%</span></label>
          <input type="range" id="contentOpacity" min="0" max="100" value="100">
          <label for="bgColor">Цвет фона:</label>
          <input type="color" id="bgColor" value="#2c3e50">
          <div class="color-preview" id="colorPreview"></div>
        </div>

        <div class="control-group">
          <h2>Инструменты</h2>
          <button id="resetBtn">Сбросить настройки</button>
          <button id="screenshotBtn">Сделать скриншот</button>
          <button id="undoBtn" disabled>Отменить (Ctrl+Z)</button>
          <label>
            <input type="checkbox" id="showFps"> Показать FPS
          </label>
        </div>
      </div>

      <div class="preview-section">
        <div class="preview-container" id="previewContainer">
          <div class="fps-counter" id="fpsCounter">FPS: 60</div>
          <div id="screenContainer">
            <div class="loading-indicator" id="loadingIndicator">Загрузка маски экрана</div>
            <img id="maskImage" src="" alt="Mask" onerror="handleImageError()" style="object-fit: contain;">
            <video id="videoPlayer" controls></video>
            <canvas id="previewCanvas"></canvas>
            <div class="placeholder-message" id="placeholderMessage">
              <h3>Загрузите контент для предпросмотра</h3>
              <p>Выберите файл изображения или видео для отображения на выбранном экране</p>
            </div>
          </div>
        </div>

        <div class="screen-info">
          <div class="info-grid">
            <div class="info-item">
              <div class="info-label">Текущий экран</div>
              <div class="info-value" id="currentScreen">Большой экран</div>
            </div>
            <div class="info-item">
              <div class="info-label">Разрешение</div>
              <div class="info-value" id="screenResolution">6528 × 1472</div>
            </div>
            <div class="info-item">
              <div class="info-label">Соотношение сторон</div>
              <div class="info-value" id="aspectRatio">102:23</div>
            </div>
            <div class="info-item">
              <div class="info-label">Масштаб</div>
              <div class="info-value" id="scalePercent">100%</div>
            </div>
            <div class="info-item">
              <div class="info-label">Загруженный контент</div>
              <div class="info-value" id="contentInfo">Нет</div>
            </div>
            <div class="info-item">
              <div class="info-label">Поворот</div>
              <div class="info-value" id="rotationInfo">0°</div>
            </div>
          </div>
        </div>

        <div class="fullscreen-btn-container">
          <button id="fullscreenBtn">Полный экран (Ctrl+F)</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========== КОНФИГУРАЦИЯ И МОДУЛИ ==========
    
    const maskCache = {};
    const imageCache = {};
    const smallScreens = ['Nav','Bar1','Bar2','TualetM','TualetW','TualetPotolok','Lestnitsa'];
    
    const displayModes = {
      CONTAIN: 'contain',
      COVER: 'cover',
      STRETCH: 'stretch',
      ORIGINAL: 'original'
    };

    const screens = {
      Bolshoi:       { w:6528, h:1472, src: 'images/Bolshoi-ekran-6528kh1472.jpg', ratio: "102:23" },
      Poloski:       { w:640,  h:1920, src: 'images/Ekran-poloski-640x1920.jpg', ratio: "1:3" },
      Nav:           { w:316,  h:384,  src: 'images/Navigation-316x384.jpg', ratio: "79:96" },
      Bar1:          { w:384,  h:64,   src: 'images/Bar 1 384x64.jpg', ratio: "6:1" },
      Bar2:          { w:256,  h:64,   src: 'images/Bar-2-256Kh64.jpg', ratio: "4:1" },
      Recepshen:     { w:2176, h:1280, src: 'images/Recepshen-2176x1280.jpg', ratio: "17:10" },
      TualetM:       { w:284,  h:256,  src: 'images/Tualet-men-284x256.jpg', ratio: "71:64" },
      TualetW:       { w:284,  h:256,  src: 'images/Tualet-women-284x256.jpg', ratio: "71:64" },
      TualetPotolok: { w:383,  h:384,  src: 'images/Tualet-potolok-383x384.jpg', ratio: "383:384" },
      Lestnitsa:     { w:200,  h:120,  src: 'images/Ekran-na-lestnice-200Kh120-1920Kh1080.jpg', ratio: "5:3" }
    };

    // ========== МОДУЛЬ State Management ==========
    const StateManager = {
      appState: {
        currentScreen: 'Bolshoi',
        scale: 100,
        opacity: 100,
        bgColor: '#2c3e50',
        displayMode: 'contain',
        content: null,
        isPlaying: false,
        rotation: 0,
        filters: {
          brightness: 100,
          contrast: 100,
          saturation: 100
        },
        showGrid: false
      },

      history: {
        states: [],
        currentIndex: -1,
        
        pushState(state) {
          this.states = this.states.slice(0, this.currentIndex + 1);
          this.states.push(JSON.parse(JSON.stringify(state)));
          this.currentIndex = this.states.length - 1;
          this.updateUndoButton();
        },

        undo() {
          if (this.currentIndex > 0) {
            this.currentIndex--;
            return JSON.parse(JSON.stringify(this.states[this.currentIndex]));
          }
          return null;
        },

        redo() {
          if (this.currentIndex < this.states.length - 1) {
            this.currentIndex++;
            return JSON.parse(JSON.stringify(this.states[this.currentIndex]));
          }
          return null;
        },

        updateUndoButton() {
          elements.undoBtn.disabled = this.currentIndex <= 0;
        }
      },

      saveState() {
        this.history.pushState(this.appState);
        localStorage.setItem('screenPreviewSettings', JSON.stringify(this.appState));
      },

      loadState() {
        const saved = localStorage.getItem('screenPreviewSettings');
        if (saved) {
          try {
            const state = JSON.parse(saved);
            Object.assign(this.appState, state);
            return true;
          } catch (e) {
            console.error('Ошибка загрузки состояния:', e);
          }
        }
        return false;
      },

      resetState() {
        this.appState = {
          currentScreen: 'Bolshoi',
          scale: 100,
          opacity: 100,
          bgColor: '#2c3e50',
          displayMode: 'contain',
          content: null,
          isPlaying: false,
          rotation: 0,
          filters: {
            brightness: 100,
            contrast: 100,
            saturation: 100
          },
          showGrid: false
        };
        this.history.states = [];
        this.history.currentIndex = -1;
        localStorage.removeItem('screenPreviewSettings');
      }
    };

    // ========== МОДУЛЬ ImageProcessor ==========
    const ImageProcessor = {
      applyFilters(canvas, filters) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const brightness = filters.brightness / 100;
        const contrast = filters.contrast / 100;
        const saturation = filters.saturation / 100;

        for (let i = 0; i < data.length; i += 4) {
          // Яркость
          data[i] = this.clamp(data[i] * brightness);
          data[i + 1] = this.clamp(data[i + 1] * brightness);
          data[i + 2] = this.clamp(data[i + 2] * brightness);

          // Контраст
          const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));
          data[i] = this.clamp(factor * (data[i] - 128) + 128);
          data[i + 1] = this.clamp(factor * (data[i + 1] - 128) + 128);
          data[i + 2] = this.clamp(factor * (data[i + 2] - 128) + 128);

          // Насыщенность (упрощенная реализация)
          if (saturation !== 1) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            data[i] = this.clamp(gray + saturation * (data[i] - gray));
            data[i + 1] = this.clamp(gray + saturation * (data[i + 1] - gray));
            data[i + 2] = this.clamp(gray + saturation * (data[i + 2] - gray));
          }
        }

        ctx.putImageData(imageData, 0, 0);
      },

      clamp(value) {
        return Math.max(0, Math.min(255, value));
      },

      resize(image, width, height, quality = 0.9) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, width, height);
        
        return canvas.toDataURL('image/jpeg', quality);
      }
    };

    // ========== МОДУЛЬ VideoManager ==========
    const VideoManager = {
      players: new Map(),
      animationFrameId: null,
      
      createPlayer(file, canvas) {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.loop = true;
        
        video.addEventListener('loadeddata', () => {
          this.setupVideoProcessing(video, canvas);
        });
        
        this.players.set(file.name, video);
        return video;
      },
      
      setupVideoProcessing(video, canvas) {
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        
        const drawFrame = () => {
          if (!isDrawing) return;
          
          try {
            if (video.readyState >= video.HAVE_CURRENT_DATA && !video.paused && !video.ended) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              
              // Применяем фильтры если нужно
              if (StateManager.appState.filters) {
                ImageProcessor.applyFilters(canvas, StateManager.appState.filters);
              }
            }
            
            if (!video.ended) {
              this.animationFrameId = requestAnimationFrame(drawFrame);
            } else {
              isDrawing = false;
            }
          } catch (error) {
            console.warn('Ошибка при отрисовке видео:', error);
            isDrawing = false;
          }
        };
        
        const startDrawing = () => {
          if (!isDrawing) {
            isDrawing = true;
            drawFrame();
          }
        };
        
        const stopDrawing = () => {
          isDrawing = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
        };
        
        video.addEventListener('play', startDrawing);
        video.addEventListener('pause', stopDrawing);
        video.addEventListener('ended', stopDrawing);
        video.addEventListener('seeked', () => {
          if (!video.paused) {
            startDrawing();
          }
        });
      },
      
      cleanup() {
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
          this.animationFrameId = null;
        }
        
        this.players.forEach((video, key) => {
          URL.revokeObjectURL(video.src);
        });
        this.players.clear();
      }
    };

    // ========== МЕТРИКИ И МОНИТОРИНГ ==========
    const Metrics = {
      startTime: Date.now(),
      interactions: 0,
      errors: 0,
      loadedFiles: 0,
      
      trackInteraction(action) {
        this.interactions++;
        console.log(`User action: ${action} | Total interactions: ${this.interactions}`);
      },
      
      trackError(error) {
        this.errors++;
        console.error('Application error:', error);
      },
      
      trackFileLoad(type, size) {
        this.loadedFiles++;
        console.log(`File loaded: ${type}, size: ${(size / 1024 / 1024).toFixed(2)}MB`);
      },
      
      getStats() {
        return {
          uptime: Date.now() - this.startTime,
          interactions: this.interactions,
          errors: this.errors,
          loadedFiles: this.loadedFiles
        };
      }
    };

    // ========== ЭЛЕМЕНТЫ DOM ==========
    const elements = {
      // Основные элементы
      sel: document.getElementById('screenSelect'),
      inFile: document.getElementById('uploadInput'),
      cont: document.getElementById('screenContainer'),
      maskImg: document.getElementById('maskImage'),
      vid: document.getElementById('videoPlayer'),
      canvas: document.getElementById('previewCanvas'),
      ctx: document.getElementById('previewCanvas').getContext('2d'),
      
      // Элементы управления
      scaleSlider: document.getElementById('scaleSlider'),
      scaleValue: document.getElementById('scaleValue'),
      autoFitBtn: document.getElementById('autoFitBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      opacitySlider: document.getElementById('contentOpacity'),
      opacityValue: document.getElementById('opacityValue'),
      bgColorPicker: document.getElementById('bgColor'),
      colorPreview: document.getElementById('colorPreview'),
      displayMode: document.getElementById('displayMode'),
      
      // Информационные элементы
      loadingIndicator: document.getElementById('loadingIndicator'),
      placeholderMessage: document.getElementById('placeholderMessage'),
      uploadError: document.getElementById('uploadError'),
      uploadSuccess: document.getElementById('uploadSuccess'),
      currentScreen: document.getElementById('currentScreen'),
      screenResolution: document.getElementById('screenResolution'),
      aspectRatio: document.getElementById('aspectRatio'),
      scalePercent: document.getElementById('scalePercent'),
      contentInfo: document.getElementById('contentInfo'),
      rotationInfo: document.getElementById('rotationInfo'),
      
      // Контейнеры
      previewContainer: document.getElementById('previewContainer'),
      controlPanel: document.getElementById('controlPanel'),
      
      // Кнопки и переключатели
      panelToggle: document.getElementById('panelToggle'),
      resetBtn: document.getElementById('resetBtn'),
      screenshotBtn: document.getElementById('screenshotBtn'),
      showFps: document.getElementById('showFps'),
      fpsCounter: document.getElementById('fpsCounter'),
      undoBtn: document.getElementById('undoBtn'),
      zoomInBtn: document.getElementById('zoomInBtn'),
      zoomOutBtn: document.getElementById('zoomOutBtn'),
      rotateBtn: document.getElementById('rotateBtn'),
      toggleGridBtn: document.getElementById('toggleGridBtn'),
      
      // Фильтры
      brightnessSlider: document.getElementById('brightnessSlider'),
      brightnessValue: document.getElementById('brightnessValue'),
      contrastSlider: document.getElementById('contrastSlider'),
      contrastValue: document.getElementById('contrastValue'),
      saturationSlider: document.getElementById('saturationSlider'),
      saturationValue: document.getElementById('saturationValue'),
      resetFiltersBtn: document.getElementById('resetFiltersBtn')
    };

    // ========== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ==========
    let currentScreenType = elements.sel.value;
    let isPortrait = window.innerHeight > window.innerWidth;
    let currentDisplayMode = displayModes.CONTAIN;
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 60;
    let currentRotation = 0;

    // ========== УТИЛИТЫ ==========
    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

    function calculateAspectRatio(width, height) {
      const d = gcd(width, height);
      const rw = width / d, rh = height / d;
      return `${rw}:${rh}`;
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function darkenColor(color, amt) {
      let r = parseInt(color.substring(1, 3), 16);
      let g = parseInt(color.substring(3, 5), 16);
      let b = parseInt(color.substring(5, 7), 16);
      r = Math.max(0, Math.floor(r * (1 - amt)));
      g = Math.max(0, Math.floor(g * (1 - amt)));
      b = Math.max(0, Math.floor(b * (1 - amt)));
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function sanitizeUrl(url) {
      try {
        return new URL(url, window.location.origin).href;
      } catch {
        return '';
      }
    }

    // ========== БЕЗОПАСНОСТЬ И ВАЛИДАЦИЯ ==========
    function validateFile(file) {
      const maxSize = 1000 * 1024 * 1024; // 1000MB
      const allowedTypes = [
        'image/jpeg', 'image/png', 'image/gif', 'image/webp',
        'video/mp4', 'video/webm', 'video/ogg'
      ];
      
      if (file.size > maxSize) {
        throw new Error('Файл слишком большой (максимум 1000MB)');
      }
      
      if (!allowedTypes.includes(file.type)) {
        throw new Error('Неподдерживаемый формат файла');
      }
      
      return true;
    }

    function validateScreenType(type) {
      return Object.keys(screens).includes(type);
    }

    // ========== УПРАВЛЕНИЕ ПАМЯТЬЮ ==========
    function cleanupMemory() {
      // Очистка кэша изображений
      Object.keys(imageCache).forEach(key => {
        if (key !== screens[elements.sel.value]?.src) {
          delete imageCache[key];
        }
      });
      
      // Очистка URL объектов
      if (elements.vid.src) {
        URL.revokeObjectURL(elements.vid.src);
        elements.vid.src = '';
      }
      
      if (elements.canvas._imageUrl) {
        URL.revokeObjectURL(elements.canvas._imageUrl);
        delete elements.canvas._imageUrl;
      }
      
      VideoManager.cleanup();
    }

    // ========== UX УЛУЧШЕНИЯ ==========
    function showFileLoading(file) {
      const progress = document.createElement('div');
      progress.className = 'file-loading';
      progress.innerHTML = `Загрузка: ${file.name}...`;
      elements.previewContainer.appendChild(progress);
      return progress;
    }

    function createPreloader() {
      const preloader = document.createElement('div');
      preloader.className = 'preloader';
      preloader.innerHTML = `
        <div class="spinner"></div>
        <p>Загрузка контента</p>
      `;
      elements.previewContainer.appendChild(preloader);
      return preloader;
    }

    function showMessage(message, type = 'error') {
      const element = type === 'success' ? elements.uploadSuccess : elements.uploadError;
      element.textContent = message;
      element.style.display = 'block';
      
      setTimeout(() => {
        element.style.display = 'none';
      }, 3000);
    }

    // ========== ОСНОВНЫЕ ФУНКЦИИ ==========
    function applyContainerSize(scr) {
      if (scr.w > 2000 || scr.h > 2000) {
        const maxWidth = elements.previewContainer.clientWidth * 0.9;
        const maxHeight = elements.previewContainer.clientHeight * 0.9;
        const scale = Math.min(maxWidth / scr.w, maxHeight / scr.h);
        
        elements.cont.style.width = (scr.w * scale) + 'px';
        elements.cont.style.height = (scr.h * scale) + 'px';
      } else {
        elements.cont.style.width = scr.w + 'px';
        elements.cont.style.height = scr.h + 'px';
      }
    }

    function updateScale() {
      const s = elements.scaleSlider.value / 100;
      elements.cont.style.transform = `scale(${s}) rotate(${currentRotation}deg)`;
      elements.scaleValue.textContent = `${elements.scaleSlider.value}%`;
      elements.scalePercent.textContent = `${elements.scaleSlider.value}%`;
      
      StateManager.appState.scale = parseInt(elements.scaleSlider.value);
      StateManager.saveState();
    }

    function zoomIn() {
      elements.scaleSlider.value = Math.min(400, parseInt(elements.scaleSlider.value) + 10);
      updateScale();
      Metrics.trackInteraction('zoom_in');
    }

    function zoomOut() {
      elements.scaleSlider.value = Math.max(10, parseInt(elements.scaleSlider.value) - 10);
      updateScale();
      Metrics.trackInteraction('zoom_out');
    }

    function rotateScreen() {
      currentRotation = (currentRotation + 90) % 360;
      elements.cont.style.transform = `scale(${elements.scaleSlider.value / 100}) rotate(${currentRotation}deg)`;
      elements.rotationInfo.textContent = `${currentRotation}°`;
      Metrics.trackInteraction('rotate');
    }

    function toggleGrid() {
      elements.canvas.classList.toggle('show-grid');
      StateManager.appState.showGrid = elements.canvas.classList.contains('show-grid');
      StateManager.saveState();
    }

    function autoFit() {
      if (!validateScreenType(elements.sel.value)) return;
      
      const scr = screens[elements.sel.value];
      const availW = elements.previewContainer.clientWidth - 40;
      const availH = elements.previewContainer.clientHeight - 40;
      
      let baseScale = smallScreens.includes(elements.sel.value) ? 2 : 1;
      
      if (scr.w > 2000 || scr.h > 2000) {
        baseScale = 0.8;
      }
      
      if (elements.sel.value === 'Bolshoi') {
        baseScale = 1.5;
      }
      
      const scale = Math.min(availW / scr.w, availH / scr.h) * 100 * baseScale;
      elements.scaleSlider.value = Math.max(10, Math.min(400, Math.floor(scale)));
      updateScale();
      Metrics.trackInteraction('auto_fit');
    }

    function updateOpacity() {
      const o = elements.opacitySlider.value / 100;
      elements.vid.style.opacity = o;
      elements.canvas.style.opacity = o;
      elements.opacityValue.textContent = `${elements.opacitySlider.value}%`;
      
      StateManager.appState.opacity = parseInt(elements.opacitySlider.value);
      StateManager.saveState();
    }

    function updateBackground() {
      const color = elements.bgColorPicker.value;
      document.body.style.background = `url('images/Back.jpg') no-repeat center center fixed, linear-gradient(to bottom, ${color}, ${darkenColor(color, 0.3)})`;
      document.body.style.backgroundSize = 'cover';
      elements.colorPreview.style.backgroundColor = color;
      
      StateManager.appState.bgColor = color;
      StateManager.saveState();
    }

    function updateDisplayMode() {
      currentDisplayMode = elements.displayMode.value;
      if (elements.inFile.files.length > 0) {
        elements.inFile.dispatchEvent(new Event('change'));
      }
      
      StateManager.appState.displayMode = currentDisplayMode;
      StateManager.saveState();
    }

    function updateFilters() {
      const filters = {
        brightness: parseInt(elements.brightnessSlider.value),
        contrast: parseInt(elements.contrastSlider.value),
        saturation: parseInt(elements.saturationSlider.value)
      };
      
      elements.brightnessValue.textContent = `${filters.brightness}%`;
      elements.contrastValue.textContent = `${filters.contrast}%`;
      elements.saturationValue.textContent = `${filters.saturation}%`;
      
      // Применяем фильтры к текущему изображению
      if (elements.canvas.style.display !== 'none') {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = elements.canvas.width;
        tempCanvas.height = elements.canvas.height;
        
        tempCtx.drawImage(elements.canvas, 0, 0);
        ImageProcessor.applyFilters(tempCanvas, filters);
        
        elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
        elements.ctx.drawImage(tempCanvas, 0, 0);
      }
      
      StateManager.appState.filters = filters;
      StateManager.saveState();
    }

    function resetFilters() {
      elements.brightnessSlider.value = 100;
      elements.contrastSlider.value = 100;
      elements.saturationSlider.value = 100;
      updateFilters();
      Metrics.trackInteraction('reset_filters');
    }

    function updateContentInfo(file = null) {
      if (file) {
        const size = (file.size / 1024 / 1024).toFixed(2);
        elements.contentInfo.textContent = `${file.type.split('/')[1].toUpperCase()} | ${size} MB`;
        StateManager.appState.content = file.name;
      } else {
        elements.contentInfo.textContent = 'Нет';
        StateManager.appState.content = null;
      }
    }

    function handleImageError() {
      elements.loadingIndicator.style.display = 'none';
      if (!validateScreenType(elements.sel.value)) return;
      
      const scr = screens[elements.sel.value];
      elements.maskImg.style.display = 'none';
      let fb = document.getElementById('fallbackCanvas');
      if (fb) fb.remove();

      const fallbackCanvas = document.createElement('canvas');
      fallbackCanvas.width = scr.w;
      fallbackCanvas.height = scr.h;
      const fctx = fallbackCanvas.getContext('2d');
      fctx.strokeStyle = '#3498db';
      fctx.lineWidth = 2;
      fctx.strokeRect(0, 0, scr.w, scr.h);
      fctx.fillStyle = '#3498db';
      fctx.font = '16px Arial';
      fctx.textAlign = 'center';
      fctx.fillText(`Экран: ${elements.sel.value}`, scr.w / 2, scr.h / 2 - 10);
      fctx.fillText(`${scr.w} × ${scr.h} пикселей`, scr.w / 2, scr.h / 2 + 10);
      fctx.fillText(`Соотношение: ${scr.ratio}`, scr.w / 2, scr.h / 2 + 30);

      fallbackCanvas.style.position = 'absolute';
      fallbackCanvas.style.inset = '0';
      fallbackCanvas.style.width = '100%';
      fallbackCanvas.style.height = '100%';
      fallbackCanvas.style.zIndex = '1';
      fallbackCanvas.id = 'fallbackCanvas';
      elements.cont.appendChild(fallbackCanvas);
    }

    function safeUpdateScreen() {
      const requestedScreen = elements.sel.value;
      if (!validateScreenType(requestedScreen)) {
        console.warn('Invalid screen type:', requestedScreen);
        return;
      }
      
      updateScreen();
    }

    function updateScreen() {
      const scr = screens[elements.sel.value];
      currentScreenType = elements.sel.value;

      const fb = document.getElementById('fallbackCanvas');
      if (fb) fb.remove();

      elements.loadingIndicator.style.display = 'block';
      elements.maskImg.style.display = 'block';

      applyContainerSize(scr);

      elements.vid.style.display = 'none';
      elements.canvas.style.display = 'none';
      elements.inFile.value = '';

      elements.currentScreen.textContent = elements.sel.options[elements.sel.selectedIndex].text;
      elements.screenResolution.textContent = `${scr.w} × ${scr.h}`;
      elements.aspectRatio.textContent = scr.ratio;
      updateContentInfo();

      if (imageCache[scr.src]) {
        elements.maskImg.src = scr.src;
        elements.loadingIndicator.style.display = 'none';
        autoFit();
      } else {
        loadImageWithRetry(scr.src)
          .then(() => {
            if (elements.sel.value === currentScreenType) {
              elements.maskImg.src = scr.src;
              imageCache[scr.src] = true;
              elements.loadingIndicator.style.display = 'none';
              autoFit();
            }
          })
          .catch(() => {
            if (elements.sel.value === currentScreenType) {
              handleImageError();
              autoFit();
            }
          });
      }
      
      StateManager.appState.currentScreen = elements.sel.value;
      StateManager.saveState();
      Metrics.trackInteraction('screen_change');
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        elements.previewContainer.requestFullscreen().catch(() => {});
        elements.fullscreenBtn.textContent = 'Выйти из полноэкранного режима';
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
          elements.fullscreenBtn.textContent = 'Полный экран (Ctrl+F)';
        }
      }
      Metrics.trackInteraction('fullscreen_toggle');
    }

    function takeScreenshot() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!validateScreenType(elements.sel.value)) return;
      
      const scr = screens[elements.sel.value];
      canvas.width = scr.w;
      canvas.height = scr.h;
      
      // Рисуем текущий контент
      if (elements.vid.style.display !== 'none') {
        ctx.drawImage(elements.vid, 0, 0, scr.w, scr.h);
      } else if (elements.canvas.style.display !== 'none') {
        ctx.drawImage(elements.canvas, 0, 0, scr.w, scr.h);
      }
      
      const link = document.createElement('a');
      link.download = `screenshot-${elements.sel.value}-${new Date().getTime()}.png`;
      link.href = canvas.toDataURL();
      link.click();
      
      showMessage('Скриншот сохранен', 'success');
      Metrics.trackInteraction('screenshot');
    }

    function undoAction() {
      const previousState = StateManager.history.undo();
      if (previousState) {
        applyState(previousState);
      }
    }

    function applyState(state) {
      elements.sel.value = state.currentScreen;
      elements.scaleSlider.value = state.scale;
      elements.opacitySlider.value = state.opacity;
      elements.bgColorPicker.value = state.bgColor;
      elements.displayMode.value = state.displayMode;
      elements.brightnessSlider.value = state.filters.brightness;
      elements.contrastSlider.value = state.filters.contrast;
      elements.saturationSlider.value = state.filters.saturation;
      
      if (state.showGrid) {
        elements.canvas.classList.add('show-grid');
      } else {
        elements.canvas.classList.remove('show-grid');
      }
      
      updateScreen();
      updateScale();
      updateOpacity();
      updateBackground();
      updateDisplayMode();
      updateFilters();
    }

    function resetSettings() {
      StateManager.resetState();
      applyState(StateManager.appState);
      showMessage('Настройки сброшены', 'success');
      Metrics.trackInteraction('reset_settings');
    }

    // ========== Preload и загрузка ==========
    function preloadMasks() {
      Object.values(screens).forEach(screen => {
        const img = new Image();
        img.onload = () => {
          imageCache[screen.src] = img;
        };
        img.src = screen.src;
      });
    }

    function loadImageWithRetry(src, retries = 3, delay = 1000) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        img.onload = () => resolve(img);
        img.onerror = () => {
          if (retries > 0) {
            setTimeout(() => {
              loadImageWithRetry(src, retries - 1, delay).then(resolve).catch(reject);
            }, delay);
          } else {
            reject(new Error(`Не удалось загрузить: ${src}`));
          }
        };
        
        img.src = src;
      });
    }

    // ========== FPS и производительность ==========
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      if (currentTime >= lastTime + 1000) {
        fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        elements.fpsCounter.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
      }
      requestAnimationFrame(updateFPS);
    }

    // ========== ЖЕСТЫ ДЛЯ МОБИЛЬНЫХ ==========
    function setupTouchGestures() {
      let initialDistance = 0;
      let initialScale = 1;

      elements.previewContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          initialDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          initialScale = parseInt(elements.scaleSlider.value) / 100;
        }
      });

      elements.previewContainer.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const currentDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          
          const scaleChange = currentDistance / initialDistance;
          const newScale = Math.max(0.1, Math.min(4, initialScale * scaleChange));
          elements.scaleSlider.value = Math.round(newScale * 100);
          updateScale();
        }
      });
    }

    // ========== ОБРАБОТЧИКИ СОБЫТИЙ ==========
    function setupEventListeners() {
      // Глобальная обработка ошибок
      window.addEventListener('error', (e) => {
        console.error('Global error:', e.error);
        Metrics.trackError(e.error);
        showMessage('Произошла ошибка приложения', 'error');
      });

      // Панель управления
      elements.panelToggle.addEventListener('click', () => {
        elements.controlPanel.classList.toggle('active');
        Metrics.trackInteraction('panel_toggle');
      });
      
      document.addEventListener('click', (e) => {
        if (window.innerWidth <= 768 &&
            !elements.controlPanel.contains(e.target) &&
            e.target !== elements.panelToggle &&
            elements.controlPanel.classList.contains('active')) {
          elements.controlPanel.classList.remove('active');
        }
      });

      // Основные элементы
      elements.sel.addEventListener('change', safeUpdateScreen);
      elements.scaleSlider.addEventListener('input', updateScale);
      elements.autoFitBtn.addEventListener('click', autoFit);
      elements.zoomInBtn.addEventListener('click', zoomIn);
      elements.zoomOutBtn.addEventListener('click', zoomOut);
      elements.rotateBtn.addEventListener('click', rotateScreen);
      elements.opacitySlider.addEventListener('input', updateOpacity);
      elements.bgColorPicker.addEventListener('input', updateBackground);
      elements.displayMode.addEventListener('change', updateDisplayMode);
      elements.resetBtn.addEventListener('click', resetSettings);
      elements.screenshotBtn.addEventListener('click', takeScreenshot);
      elements.fullscreenBtn.addEventListener('click', toggleFullscreen);
      elements.undoBtn.addEventListener('click', undoAction);
      elements.toggleGridBtn.addEventListener('change', toggleGrid);
      
      // Фильтры
      elements.brightnessSlider.addEventListener('input', updateFilters);
      elements.contrastSlider.addEventListener('input', updateFilters);
      elements.saturationSlider.addEventListener('input', updateFilters);
      elements.resetFiltersBtn.addEventListener('click', resetFilters);
      
      elements.showFps.addEventListener('change', (e) => {
        elements.fpsCounter.style.display = e.target.checked ? 'block' : 'none';
      });

      // Загрузка файлов
      elements.inFile.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;

        elements.placeholderMessage.style.display = 'none';
        elements.uploadError.style.display = 'none';
        elements.uploadSuccess.style.display = 'none';

        const progress = showFileLoading(file);

        try {
          validateFile(file);
        } catch (error) {
          showMessage(error.message);
          progress.remove();
          return;
        }

        if (!validateScreenType(elements.sel.value)) {
          showMessage('Неверный тип экрана');
          progress.remove();
          return;
        }

        const scr = screens[elements.sel.value];
        const cw = scr.w, ch = scr.h;

        if (file.type.startsWith('image/')) {
          elements.vid.style.display = 'none';
          elements.canvas.style.display = 'block';
          elements.canvas.width = cw;
          elements.canvas.height = ch;

          const img = new Image();
          img.onload = () => {
            elements.ctx.clearRect(0, 0, cw, ch);
            
            let x = 0, y = 0, width = cw, height = ch;
            
            switch(currentDisplayMode) {
              case displayModes.COVER:
                const scaleCover = Math.max(cw / img.width, ch / img.height);
                width = img.width * scaleCover;
                height = img.height * scaleCover;
                x = (cw - width) / 2;
                y = (ch - height) / 2;
                break;
                
              case displayModes.STRETCH:
                // Используем полный размер canvas
                break;
                
              case displayModes.ORIGINAL:
                width = img.width;
                height = img.height;
                x = (cw - width) / 2;
                y = (ch - height) / 2;
                break;
                
              default: // CONTAIN
                const scaleContain = Math.min(cw / img.width, ch / img.height);
                width = img.width * scaleContain;
                height = img.height * scaleContain;
                x = (cw - width) / 2;
                y = (ch - height) / 2;
            }
            
            elements.ctx.drawImage(img, x, y, width, height);
            
            // Применяем фильтры если нужно
            if (StateManager.appState.filters) {
              updateFilters();
            }
            
            updateContentInfo(file);
            showMessage('Изображение успешно загружено', 'success');
            progress.remove();
            Metrics.trackFileLoad('image', file.size);
          };
          
          img.onerror = () => {
            showMessage('Ошибка загрузки изображения');
            elements.placeholderMessage.style.display = 'block';
            progress.remove();
            Metrics.trackError(new Error('Image load error'));
          };
          
          img.src = URL.createObjectURL(file);
          elements.canvas._imageUrl = img.src;
          elements.canvas.style.opacity = elements.opacitySlider.value / 100;
          
        } else if (file.type.startsWith('video/')) {
          elements.canvas.style.display = 'none';
          elements.vid.style.display = 'block';
          
          // Останавливаем предыдущее видео и очищаем
          elements.vid.pause();
          URL.revokeObjectURL(elements.vid.src);
          
          elements.vid.onerror = () => {
            showMessage('Ошибка загрузки видео');
            elements.placeholderMessage.style.display = 'block';
            progress.remove();
            Metrics.trackError(new Error('Video load error'));
          };
          
          elements.vid.onloadeddata = () => {
            updateContentInfo(file);
            showMessage('Видео успешно загружено', 'success');
            progress.remove();
            Metrics.trackFileLoad('video', file.size);
            
            // Автовоспроизведение с обработкой ошибок
            elements.vid.play().catch(error => {
              console.warn('Автовоспроизведение заблокировано:', error);
              // Показываем сообщение, что нужно запустить видео вручную
              showMessage('Нажмите play для воспроизведения видео', 'success');
            });
          };
          
          elements.vid.onended = () => {
            console.log('Видео завершено');
            // Можно добавить автоматическое повторение или другие действия
          };
          
          elements.vid.src = URL.createObjectURL(file);
          elements.vid.loop = true; // Зацикливание видео
          elements.vid.style.opacity = elements.opacitySlider.value / 100;
        }
        
        StateManager.saveState();
      });

      // Горячие клавиши
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key.toLowerCase()) {
            case '+': case '=':
              e.preventDefault();
              zoomIn();
              break;
            case '-':
              e.preventDefault();
              zoomOut();
              break;
            case '0':
              e.preventDefault();
              autoFit();
              break;
            case 'f':
              e.preventDefault();
              toggleFullscreen();
              break;
            case 'z':
              e.preventDefault();
              undoAction();
              break;
          }
        }
      });

      // Адаптация к изменению размера
      const optimizedResize = debounce(function() {
        const newIsPortrait = window.innerHeight > window.innerWidth;
        if (newIsPortrait !== isPortrait) {
          isPortrait = newIsPortrait;
          safeUpdateScreen();
        } else {
          autoFit();
        }
      }, 100);

      window.addEventListener('resize', optimizedResize);
      window.addEventListener('orientationchange', debounce(function() {
        isPortrait = window.innerHeight > window.innerWidth;
        safeUpdateScreen();
      }, 300));

      // Полноэкранный режим
      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
          elements.fullscreenBtn.textContent = 'Полный экран (Ctrl+F)';
        }
      });

      // Жесты для мобильных
      setupTouchGestures();
    }

    // ========== ИНИЦИАЛИЗАЦИЯ ==========
    function init() {
      preloadMasks();
      setupEventListeners();
      
      // Загрузка состояния
      if (StateManager.loadState()) {
        applyState(StateManager.appState);
        showMessage('Настройки загружены', 'success');
      } else {
        // Первоначальное состояние
        StateManager.saveState();
      }
      
      updateFPS();
      
      // Установка начальных значений
      updateScale();
      updateBackground();
      updateFilters();
      elements.colorPreview.style.backgroundColor = elements.bgColorPicker.value;
      
      // Периодическая очистка памяти
      setInterval(cleanupMemory, 30000);
      
      // Очистка при разгрузке страницы
      window.addEventListener('beforeunload', cleanupMemory);
      
      console.log('Screen Preview инициализирован');
      console.log('Метрики:', Metrics.getStats());
    }

    // Запуск при загрузке страницы
    window.addEventListener('load', init);
  </script>
</body>
</html>
